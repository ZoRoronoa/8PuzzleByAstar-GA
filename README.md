# 实验设计

## 1.1 概述

本项目的功能代码与界面代码相分开，整个项目的结构图如图1所示。其中，`astar.py`为实现`astar`算法的包，`ga.py`为实现了遗传算法的包，`main.py`为主文件，其中包含了GUI的编写以及对以上两种算法的调用，程序在`main.py`处执行。

External Libraries为编译器自带工具，展示在项目中使用到的外部文件。



![img](https://github.com/ZoRoronoa/8PuzzleByAstar-GA/blob/master/IMAGE/clip_image001.png)

具体的项目架构图如下图所示：

![img](https://github.com/ZoRoronoa/8PuzzleByAstar-GA/blob/master/IMAGE/clip_image003.png)



## 1.2算法描述：对于A*算法

### 1.2.1 状态的表示

![img](https://github.com/ZoRoronoa/8PuzzleByAstar-GA/blob/master/IMAGE/clip_image005.png)

​    其中，`Board()`为棋盘的类，`move_left`、`move_right`、`move_up`、`move_down`四个函数控制棋盘的移动，`state`为初始化棋盘的状态，`end_state`为棋盘需要移动到的目标状态，`g`和`h`为启发式函数的两个分量，其中h的值由函数`cal_h()` 计算，`parent`为当前棋盘的父节点(也是一个棋盘)，若为首节点则父节点为空, `a_star()`函数为算法控制单元，`is_end_state() `检测当前棋盘是否已经达到目标棋盘的状态。`Find_where() `函数寻找数码’9’的位置，`get_node_in_open()`` nd_node_in_list()` 负责在对应的列表中寻找符合要求的节点，以便完成后续的加入列表或者删除等操作。

### 1.2.2 启发式函数的选择

本实验选择的启发式函数为曼哈顿优先级函数，即用h值表示方块与它们目标位置的曼哈顿距离的总和（垂直距离与水平距离的总和），h值通过函数`cal_h() `计算得到；g值表示达到本届点时移动的次数，通过每次移动的自增完成。

### 1.2.3 算法流程的伪代码：

```a_star()
 {
 open = [];
 closed = [];

 open.appenf(初始节点);
 while (Open表非空)
 {
 　从open中取得一个节点X;

  从open表中删除该节点;

将该节点加入到closed表中;
 　if (X是目标节点)
 　{
 　　  求得空格移动的路径PATH；
 　　  返回路径PATH；
 　}

获取该节点的所有子节点;
 　for (每一个X的子节点Y)
 　{
 　　if (Y在closed表中)
 　　{

   if(Y的代价小于closed 表中该节点的代价)
   {
 	更新closed该点的代价;

 	将该点加入open表中;

 	将该店从closed表中移出;
   }
  }
  elif(Y在open表中)
 {
   　  if (Y的代价小于open表中该节点的代价)
 　　　　  更新open表中的代价;　　　
  }
 　　else if (Y在OPEN表中)
 　　{
 　　　if (Y的估价值小于OPEN表的估价值)
 　　　　更新OPEN表中的估价值；
 　　}
 　　else //Y在CLOSE表中
 　　{
 　　　　将该节点加入至open表中;

 }
 　}//end for
 }//end while
 }//end function
```



## 1.3算法描述：对于遗传算法(GA)算法：

 

### 1.3.1 染色体的编码表示

​    遗传算法的编码是解决问题的第一步，在我看来，这也是让我困惑很久的问题之一，也是理解本算法的基础。书上的例题考虑的是数字的编码，这很容易理解。但本问题的编码却不能采用最直观的数字编码，这里采用的编码方式是将空格移动的方向编码成为染色体，比如某一染色体序列为`[D, R, R, U, L, L, D, R, U, D, D, R, U, L]`表示初始棋盘经过了向下、向右、向右、向左、向左、向下、向右、向上、向下、向下、向右、向上、向左这样一系列操作之后的棋盘，再通过染色体向棋盘状态的函数映射计算出其适应度，个体的变异、染色体的交叉都是按照这样的编码方式表示并且完成。  

这里采用的交叉算子是多点交叉。

### 1.3.2 选择以及适应度函数的选取

​    这里采用的选择是基于适应度比例中的繁殖池选择方式，即选择没代个体中的适应度最优的一些个体，这里选择的个体数量是10，也即选择率是10/34≈30%。

   适应度函数的选取是棋盘中各个数码(不包括空格)距离目标位置的距离(x距离和y距离)之和。

### 1.3.3 交叉操作

​    每次从经过上次选择得到的10个个体中随机选择8个个体，两两配对，得到4对个体。在(0, `CHROMOSOME_LENGTH`)中间选择两个随机数，对每条染色体的3段重新分配，得到6个新的染色体(实际上可以得到很多种组合，在这里考虑到种群数量的限制，只取其中的6个)。这样就一共产生了24个新的个体，加之选择得到的10个个体，每代种群的个体数量维持在34。

​    由以上得知，设置的交叉概率是8/10 = 0.8

### 1.3.4 变异操作

​    变异功能有两个操作完成：
​    \1. 在染色体长度固定的情况下，通过对染色体进行检测。譬如，如果出现了明显的无效操作会随机对染色体进行改变，比如向左、向右是相邻的两个操作，那么第二个操作将随机改变为其非向右的操作；或者连续向上、向左3次这样的无效操作，将会修改第一个操作为非向上以及非向下的操作（即向左或向右）的操作。

​    \2. 考虑到一定长度的染色体操作可能难以完成目标，每隔`ADDED_INTERVAL_GEN`代我们会将染色体的长度增加`ADDED_LENGTH`长度，由上一代选择操作和交叉操作留下来的个体由于染色体长度不足，少的那部分长度的染色体会再次随机生成。

​    通过以上操作完成染色体的自我更新，变异的概率由参数`ADDED_INTERVAL_GEN`和`ADDED_LENGTH` 控制。

 

### 1.3.5 状态的表示

![img](https://github.com/ZoRoronoa/8PuzzleByAstar-GA/blob/master/IMAGE/clip_image007.png)

   `MAX_GENERATION`表示遗传算法迭代的最大次数，在本实验当中，通过测试发现，多数实验在500代以内可以完成，已经测试的实验中全部在1000代以内完成，故将`MAX_GENERATION`设置为1000。`POPULATION_SIZE`设置为34，其构成为10+4*6， 即上一代选择得到的十个个体，以及十个个体当中的8个（4对）个体交叉得到的24个新个体（每对个体得到6个新个体）。由此，我们的交叉的概率Pj为0.8。

`CHROMOSOME_LENGTH`为初始个体的染色体长度，考虑到棋盘的多样性和算法的效率，一定长度的染色体长度可能难以找到解决问题的策略，因此我设置了`ADDED_LENGTH`和`ADDED_INTERVAL_GEN`两个参数，控制染色体在一定的代数之后增加它的长度，以增加它在短时间内解决问题的可能性。`SELECTED_INDIVIDUALS`表示每一代自然选择留下的个体，这里设置为10个，`begin_state`和`end_state`分别表示棋盘的初始状态和目标状态。

### 2.3.6 GA算法的伪代码

```GA()
 {

  初始化参数;

  设定初始棋盘状态、设定目标棋盘状态;

  初始化种群;

  while(代数 < 最大代数)

  {

    for(每一个种群中的个体)

    完成变异操作;

    选择操作;

    计算适应度;

    if(适应度 < 最小适应度)

      最小适应度 = 适应度;

    if(代数增加了ADDED_INTERVAL_GEN)

      染色体长度+=ADDED_LENGTH

    if(适应度==0)

      break;

    交叉操作;

  }//end while

}//end function
```


